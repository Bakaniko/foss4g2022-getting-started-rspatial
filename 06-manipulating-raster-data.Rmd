# Manipulating raster data

<!-- (Jakub) Raster data processing (45 min) -->

This chapter requires the following packages:

```{r 06-manipulating-raster-data-1 }
#| message = FALSE
library(tmap)
library(sf)
library(terra)
```

## Example data

We will read a few datasets for this chapter.
It includes `srtm.tif` -- an elevation raster data the Zion National Park area:
<!-- [](https://geocompr.robinlovelace.net/read-write.html#raster-data-read) -->

```{r 06-manipulating-raster-data-2 }
srtm_path <- system.file("raster/srtm.tif", package = "spDataLarge")
srtm <- rast(srtm_path)
```

We can quickly look at this dataset's summary by just typing its name:

```{r 06-manipulating-raster-data-3}
srtm
```

We can also extract each information separately using the following functions:

```{r 06-manipulating-raster-data-4 }
#| collapse = TRUE,
#| results = "hold"
ncol(srtm)
nrow(srtm)
nlyr(srtm)
res(srtm)
ext(srtm)
```

Next, we can quickly look at the data with the `plot()` function...

```{r 06-manipulating-raster-data-5 }
plot(srtm)
```

... or create more customized map with the {tmap} package:

```{r 06-manipulating-raster-data-6 }
tm_shape(srtm) +
  tm_graticules() +
  tm_raster(style = "cont", 
            title = "elevation (m a.s.l)",
            palette = "-Spectral") +
  tm_scale_bar(breaks = c(0, 2, 4),
               text.size = 1) +
  tm_credits("Jakub Nowosad, 2022") +
  tm_layout(inner.margins = 0,
            main.title = "Zion National Park")
```

Additional raster dataset we use in this chapter is `nlcd.tif` -- a simplified version of the National Land Cover Database 2011 product for the Zion National Park area.

```{r 06-manipulating-raster-data-7 }
nlcd <- rast(system.file("raster/nlcd.tif", package = "spDataLarge"))
```

## Map algebra

Map algebra is used for a various task related to spatial raster data processing and analysis.

It can be divided into four groups of operations:

1. **Local** - per-cell operations
2. **Focal** - most often the output cell value is the result of a 3 x 3 input cell block
3. **Zonal** - to summarize raster values for some zones (usually irregular areas)
4. **Global** - to summarize raster values for one or several rasters

### Local operations

Numerical computations are basic examples of local operations -- we can create new raster objects by, for example, adding or subtracting existing values:

```{r 06-manipulating-raster-data-8 }
srtm2 <- srtm + 1000
srtm3 <- srtm - 1024
srtm4 <- srtm - 1837
```

```{r 06-manipulating-raster-data-9, purl=FALSE,echo=FALSE, message=FALSE, out.width="100%", fig.height=3.8, fig.width=12}
tm1 <- tm_shape(srtm) +
  # tm_graticules() +
  tm_raster(style = "cont", palette = "-Spectral", breaks = seq(-1000, 4000, by = 1000)) +
  tm_layout(legend.bg.color = "white")
tm2 <- tm_shape(srtm2) +
  # tm_graticules() +
  tm_raster(style = "cont", palette = "-Spectral", breaks = seq(-1000, 4000, by = 1000)) +
  tm_layout(legend.bg.color = "white")
tm3 <- tm_shape(srtm3) +
  # tm_graticules() +
  tm_raster(style = "cont", palette = "-Spectral", breaks = seq(-1000, 4000, by = 1000)) +
  tm_layout(legend.bg.color = "white")
tm4 <- tm_shape(srtm4) +
  # tm_graticules() +
  tm_raster(style = "cont", palette = "-Spectral", breaks = seq(-1000, 4000, by = 1000),
            midpoint = NA) +
  tm_layout(legend.bg.color = "white")
tmap_arrange(tm1, tm2, tm3, tm4, nrow = 1)
```

Another example of local operation is when we want to replace some values.
This can be done by either `subst()` or `classify()`.
The `subst()` function is useful when we want to quickly replace some value(s).

```{r 06-manipulating-raster-data-10 }
srtm_new <- subst(srtm, 1500:2000, NA)
```

```{r 06-manipulating-raster-data-11, purl=FALSE,echo=FALSE, message=FALSE, out.width="100%", fig.height=3.8, fig.width=12}
library(tmap)
tm1 <- tm_shape(srtm) +
  # tm_graticules() +
  tm_raster(style = "cont")
tm2 <- tm_shape(srtm_new) +
  # tm_graticules() +
  tm_raster(style = "cont")
tmap_arrange(tm1, tm2, nrow = 1)
```

On the other hand, the `classify()` function is more useful when we want to replace many values.
It requires at least two arguments -- our input raster and a reclassification table.
Reclassification table is a matrix usually with two columns (old/new) or three columns (from/to/new):

```{r 06-manipulating-raster-data-12 }
rcl <- matrix(c(0, 1500, 1, 1500, 2000, 2, 2000, 9999, 3),
             ncol = 3, byrow = TRUE)
rcl
```

```{r 06-manipulating-raster-data-13 }
srtm_recl <- classify(srtm, rcl = rcl)
```

```{r 06-manipulating-raster-data-14, purl=FALSE,echo=FALSE}
tmr1 <- tm_shape(srtm) +
  # tm_graticules() +
  tm_raster(style = "cont") +
  tm_layout(legend.frame = TRUE)
tmr2 <- tm_shape(srtm_recl) +
  # tm_graticules() +
  tm_raster(style = "cat") +
  tm_layout(legend.frame = TRUE)
tmap_arrange(tmr1, tmr2)
```

The last example of local operation is useful when we have many raster layers and want to calculate, for example, spectral indices, such as NDVI.
In this case, each cell's values are treated independently.

To showcase local operations on many layers, we will use the `landsat.tif` dataset.
It contains four bands (2, 3, 4, 5) of the Landsat 8 image for the area of Zion National Park.

```{r 06-manipulating-raster-data-15 }
landsat_path <- system.file("raster/landsat.tif", package = "spDataLarge")
landsat <- rast(landsat_path)
landsat
```

```{r 06-manipulating-raster-data-16, message=FALSE, echo=FALSE}
tm_shape(landsat) +
  tm_raster(style = "cont") +
  tm_facets(ncol = 4)
```

[Normalized Difference Vegetation Index (NDVI)](https://en.wikipedia.org/wiki/Normalized_difference_vegetation_index) is one of the most commonly used spectral index.
It uses values of two bands: red (3) and near-infrared (4):

$$
\begin{split}
NDVI&= \frac{\text{NIR} - \text{Red}}{\text{NIR} + \text{Red}}\\
\end{split}
$$

The above equation can be rewritten as an R function that accepts two arguments, and returns a result of the calculations.

```{r 06-manipulating-raster-data-17 }
ndvi_fun <- function(nir, red){
  (nir - red) / (nir + red)
}
```

Now, we can apply our `ndvi_fun()` to the `lapp()` function.
The only important thing we need to remember is to subset our raster to contain only the needed layers:

```{r}
ndvi <- lapp(landsat[[c(4, 3)]], fun = ndvi_fun)
```

```{r 06-manipulating-raster-data-18, purl=FALSE,echo=FALSE, message=FALSE}
tml1 = tm_shape()
tm_shape(ndvi) +
  tm_raster(style = "cont", title = "NDVI")
```

### Focal operations

Focal operations, also known as moving window operations, apply a function for a given window around each cell.
A numeric vector or a matrix can represent a window.
In the example below, we calculate an average of 3 by 3 cells window for each (focal) cell.

```{r 06-manipulating-raster-data-19 }
srtm_focal_mean <- focal(srtm, w = c(3, 3), fun = "mean")
```

```{r 06-manipulating-raster-data-20, purl=FALSE,echo=FALSE}
tmf1 <- tm_shape(srtm) +
  # tm_graticules() +
  tm_raster(style = "cont") +
  tm_layout(legend.frame = TRUE)
tmf2 <- tm_shape(srtm_focal_mean) +
  # tm_graticules() +
  tm_raster(style = "cont") +
  tm_layout(legend.frame = TRUE)
tmap_arrange(tmf1, tmf2)
```

### Zonal operations

Zonal operations are also known as zonal statistics.
They calculate summary statistics independently for each provided "zone" (a category in a second raster), and their result is a summary table.

In this example, we want to calculate an average elevation (from `srtm`) for each land cover category (from `nlcd`).
However, firstly we need to have both datasets in the same coordinate reference system.
We can do that with the `project()` function:

```{r 06-manipulating-raster-data-21 }
srtm_utm <- project(srtm, nlcd, method = "bilinear")
```

```{r 06-manipulating-raster-data-23 }
srtm_zonal <- zonal(srtm_utm, nlcd, na.rm = TRUE, fun = "mean")
srtm_zonal
```

```{r 06-manipulating-raster-data-22, purl=FALSE, warning=FALSE, echo=FALSE, message=FALSE}
tmz1 <- tm_shape(srtm_utm) +
  # tm_graticules() +
  tm_raster(style = "cont") +
  tm_layout(legend.frame = TRUE)
tmz2 <- tm_shape(nlcd) +
  tm_raster(drop.levels = TRUE) +
  tm_layout(legend.frame = TRUE)
tmap_arrange(tmz1, tmz2)
```

### Global operations

Global operations provide statistics for the entire raster.

```{r 06-manipulating-raster-data-24 }
global(srtm, fun = "mean")
```

## Transformations

### Resampling

```{r 06-manipulating-raster-data-26 }
srtm
```

```{r 06-manipulating-raster-data-27 }
new_srtm <- srtm
res(new_srtm) <- 0.001
new_srtm
```

```{r 06-manipulating-raster-data-28 }
srtm2 <- resample(srtm, new_srtm, method = "bilinear") # method!
srtm2
```

### Reprojecting rasters

```{r 06-manipulating-raster-data-29 }
crs(srtm, describe = TRUE)
```

```{r 06-manipulating-raster-data-30 }
hist(srtm)
```

```{r 06-manipulating-raster-data-31, purl=FALSE,echo=FALSE}
tm_shape(srtm) + 
  tm_grid() +
  tm_raster(style = "cont",
            legend.show = FALSE)
```

https://projectionwizard.org/

```{r 06-manipulating-raster-data-32 }
srtm_utm <- project(srtm, "EPSG:32612", method = "bilinear")
crs(srtm_utm, describe = TRUE)
```

```{r 06-manipulating-raster-data-33, purl=FALSE,echo=FALSE, fig.height=7}
tm_shape(srtm) + 
  tm_grid() + 
  tm_raster(style = "cont") + 
  tm_layout(legend.show = FALSE)
```

```{r 06-manipulating-raster-data-34, purl=FALSE,echo=FALSE, fig.height=7, eval=FALSE}
tm_shape(srtm_utm) + 
  tm_grid() + 
  tm_raster(style = "cont") + 
  tm_layout(legend.show = FALSE)
```


## Raster-vector interactions

Raster and vector datasets can interact in many ways.
It includes:

- raster cropping and masking by vector polygons
- extraction of raster values by vector points, lines, and polygons
- rasterization: converting vector points, lines, polygons to rasters
- vectorization: converting rasters to polygons or contours

Here, we will focus only on raster cropping and masking, and raster extraction by points.
Read the [raster-vector interactions](https://geocompr.robinlovelace.net/raster-vector.html) chapter of the Geocomputation with R book to learn more.

### Raster cropping and masking

In this example, our goal is to limit the raster data to the area of a polygon.
Therefore, we need to read our polygon dataset, `zion.gpkg`, representing the borders of Zion National Park:

```{r 06-manipulating-raster-data-35 }
zion <- read_sf(system.file("vector/zion.gpkg", package = "spDataLarge"))
```

Raster cropping (`crop()`) limits the raster data (first argument) extent to the bounding box of the vector data (second argument).

```{r 06-manipulating-raster-data-36 }
srtm_utm_c <- crop(srtm_utm, zion)
```

Raster masking (`mask()`) is usually done together with cropping.
This operation replaces values of all the cells outside the polygon to `NA`:

```{r 06-manipulating-raster-data-38 }
srtm_utm_m <- mask(srtm_utm_c, zion)
```

```{r 06-manipulating-raster-data-39, echo=FALSE, purl=FALSE, message=FALSE, warning=FALSE}
tc1 <- tm_shape(srtm_utm) +
  tm_raster(style = "cont") +
  tm_shape(zion) +
  tm_borders() +
  tm_layout(inner.margins = 0, main.title = "Original")
tc2 <- tm_shape(srtm_utm_c) +
  tm_raster(style = "cont") +
  tm_shape(zion) +
  tm_borders() +
  tm_layout(inner.margins = 0, main.title = "Cropped")
tc3 <- tm_shape(srtm_utm_m) +
  tm_raster(style = "cont") +
  tm_shape(zion) +
  tm_borders() +
  tm_layout(inner.margins = 0, main.title = "Cropped and masked")
tmap_arrange(tc1, tc2, tc3)
```

### Raster extraction

Raster extraction allows to get value(s) of raster cells based on vector data locations.
For this example, we will use 30 points located in Zion National Park stored in the `zion_points.gpkg` file:

```{r 06-manipulating-raster-data-40 }
zion_points <- read_sf(system.file("vector/zion_points.gpkg", package = "spDataLarge"))
```

```{r 06-manipulating-raster-data-41, purl=FALSE,echo=FALSE}
tm_shape(srtm) +
  tm_raster(style = "cont") +
  tm_shape(zion_points) +
  tm_symbols()
```

The `extract()` function returns a data frame where the `ID` column represents each vector feature (a point in this case), and the rest of the columns store extracted values.
Next, we can connect the extracted values with the vector object using the `cbind()` function:

```{r 06-manipulating-raster-data-42 }
zion_extract <- terra::extract(srtm, zion_points)
zion_points <- cbind(zion_points, zion_extract)
zion_points
```

<!-- exact = TRUE -->

## Raster analysis

### Predictions

```{r 06-manipulating-raster-data-49 }
landsat_path <- system.file("raster/landsat.tif", package = "spDataLarge")
landsat <- rast(landsat_path)
zion_points_utm <- st_transform(zion_points, crs = crs(landsat))
landsat_s <- stretch(landsat, maxq = 0.98)
plotRGB(landsat_s, r = 3, g = 2, b = 1)
plot(st_geometry(zion_points_utm), add = TRUE, col = "red", cex = 3)
```

`?predict` - `glm`, `randomForest`, `prcomp`

```{r 06-manipulating-raster-data-50 }
zion_points_utm_v <- extract(landsat_s, zion_points_utm)
pca <- prcomp(zion_points_utm_v[-1])
pca
```

`?predict` - `glm`, `randomForest`, `prcomp`

```{r 06-manipulating-raster-data-51 }
pca_pred <- predict(landsat_s, pca)
plot(pca_pred)
```

### Interpolations

`?interpolate`

```{r 06-manipulating-raster-data-52 }
zion_points_srtm <- extract(srtm_utm, zion_points_utm)
```

```{r 06-manipulating-raster-data-53, message=FALSE}
library(fields)
tps <- Tps(st_coordinates(zion_points_utm),
          zion_points_utm$srtm)
rt <- rast(srtm_utm)
interp1 <- interpolate(rt, tps)
```

```{r 06-manipulating-raster-data-54 }
plot(interp1)
```

```{r 06-manipulating-raster-data-55 }
library(gstat)
interpolate_gstat <- function(model, x, crs, ...) {
	v = st_as_sf(x, coords = c("x", "y"), crs = crs)
	p = predict(model, v, ...)
	as.data.frame(p)[, 1:2]
}
```

```{r 06-manipulating-raster-data-56, warning=FALSE}
v <- variogram(srtm ~ 1, data = zion_points_utm)
# plot(v)
mv <- fit.variogram(v, vgm(120000, "Exp", 12000, nugget = 10000))
```

```{r 06-manipulating-raster-data-57 }
plot(v, model = mv)
```

```{r 06-manipulating-raster-data-58, cache = TRUE, warning=FALSE}
g_OK <- gstat(NULL, "srtm", srtm ~ 1, zion_points_utm, model = mv)
OK <- interpolate(rt, g_OK, debug.level = 0, fun = interpolate_gstat,
                 crs = crs(rt), index = 1)
plot(OK)
```

### Segmentations

https://github.com/Nowosad/supercells

```{r 06-manipulating-raster-data-59 }
library(supercells)
ortho <- rast(system.file("raster/ortho.tif", package = "supercells"))
plot(ortho)
```

```{r 06-manipulating-raster-data-60, message=FALSE, results='hide'}
ortho_slic1 <- supercells(ortho, k = 200, compactness = 10)
plot(ortho)
plot(st_geometry(ortho_slic1), add = TRUE)
```

```{r 06-manipulating-raster-data-61 }
rgb_to_hex <- function(x){
  apply(t(x), 2, function(x) rgb(x[1], x[2], x[3], maxColorValue = 255))
}
avg_colors <- rgb_to_hex(st_drop_geometry(ortho_slic1[4:6]))

plot(ortho)
plot(st_geometry(ortho_slic1), add = TRUE, col = avg_colors)
```


## Raster writing

Writing raster objects back to the files is possible with `writeRaster()`.
It allows, for example, to provide GDAL driver-specific creation options (`gdal`), output data type (`datatype`), or file type (`filetype`):

```{r 06-manipulating-raster-data-48, eval=FALSE}
writeRaster(nlcd, filename = "nlcd0.tif")
writeRaster(nlcd, filename = "nlcd1.tif", gdal = c("COMPRESS=NONE"))
writeRaster(nlcd, filename = "nlcd2.tif", datatype = "INT1U")
writeRaster(nlcd, filename = "nlcd3.tif", filetype = "COG")
```

To learn more about raster writing visit the [Geocomputation with R ](https://geocompr.robinlovelace.net/read-write.html#data-output) book and the [official GDAL](https://gdal.org/drivers/raster/gtiff.html) documentation. 


## Exercises

<!-- try hillshade -->
<!-- create a map of nlcd -->
<!-- https://bleutner.github.io/RStoolbox/rstbx-docu/spectralIndices.html -->
<!-- - global + freq + areas (cellSize()) -->
